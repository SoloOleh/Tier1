# Домашнє завдання: Моделювання транспортної мережі міста Львів

## Завдання 1: Створення та візуалізація графа транспортної мережі

У цьому завданні я створив граф для моделювання транспортної мережі міста Львів за допомогою бібліотеки networkX в Python. Граф містить 15 вершин, які представляють центральні райони та інші частини міста, і 22 ребра, що моделюють маршрути громадського транспорту, які з'єднують ці райони.

Візуалізація графа:

![Граф транспортної мережі](graph_visualization.png)

Проведений аналіз основних характеристик графа:

- Кількість вершин: 15
- Кількість ребер: 22
- Ступені вершин:
  - Центр: 3
  - Сихів: 4
  - Личаків: 5
  - Франківський: 4
  - Шевченківський: 5
  - Залізничний: 3
  - Левандівка: 4
  - Рясне: 4
  - Збоїща: 3
  - Козельники: 3
  - Білогорща: 2
  - Майорівка: 2
  - Зубра: 1
  - Кульпарків: 2
  - Богданівка: 1

## Завдання 2: Реалізація алгоритмів DFS та BFS для пошуку шляхів

Я реалізував алгоритми пошуку в глибину (DFS) та пошуку в ширину (BFS) для знаходження шляхів між вершинами в побудованому графі транспортної мережі.

Приклад виконання алгоритмів DFS та BFS, починаючи з вершини 'Центр':

Шлях DFS від вершини 'Центр': Центр -> Личаків -> Рясне -> Левандівка -> Козельники -> Білогорща -> Майорівка -> Кульпарків -> Богданівка -> Збоїща -> Шевченківський -> Франківський -> Залізничний -> Зубра -> Сихів
Шлях BFS від вершини 'Центр': Центр -> Сихів -> Личаків -> Франківський -> Шевченківський -> Залізничний -> Левандівка -> Рясне -> Збоїща -> Зубра -> Козельники -> Білогорща -> Майорівка -> Кульпарків -> Богданівка

Як видно з результатів, алгоритм DFS спочатку проходить по одній гілці графа максимально глибоко, а потім переходить до наступної гілки. Натомість BFS обходить вершини за рівнями, спочатку відвідуючи найближчі сусідні вершини.

Причини відмінностей в отриманих шляхах:
- DFS використовує стратегію "йти в глибину", тому він обходить вершини в порядку, в якому їх зустрічає, не переривається та не переходить до наступної гілки, поки не досягне кінця поточної.
- BFS обходить вершини за рівнями від початкової вершини, тому він відвідує спочатку найближчі сусідні вершини, а потім переходить до наступного рівня.

## Завдання 3: Реалізація алгоритму Дейкстри

Я додав ваги до ребер графа, які моделюють, наприклад, відстані чи час у дорозі між районами міста. Потім реалізував алгоритм Дейкстри для знаходження найкоротших шляхів між усіма вершинами графа.

Приклад знаходження найкоротших шляхів від вершини 'Центр':

Найкоротші шляхи від вершини 'Центр':
Центр -> Центр: 0
Центр -> Сихів: 4
Центр -> Личаків: 2
Центр -> Франківський: 3
Центр -> Шевченківський: 5
Центр -> Залізничний: 7
Центр -> Левандівка: 4
Центр -> Рясне: 7
Центр -> Збоїща: 9
Центр -> Козельники: 9
Центр -> Білогорща: 11
Центр -> Майорівка: 15
Центр -> Зубра: 10
Центр -> Кульпарків: 18
Центр -> Богданівка: 20

Алгоритм Дейкстри знаходить найкоротші шляхи від заданої початкової вершини до всіх інших вершин у графі, враховуючи ваги ребер. Це дозволяє ефективно моделювати найкоротші маршрути руху між районами міста, якщо відомі відстані чи часові витрати на проїзд між ними.